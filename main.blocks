<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="mT,gs]dd4OU4O1;WEWAD" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="EHXqlLGRXBzE{ae_j+@r" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum segment {" line1="   dp = 0b01111111," line2="    g = 0b10111111," line3="    f = 0b11011111," line4="    e = 0b11101111," line5="    d = 0b11110111," line6="    c = 0b11111011," line7="    b = 0b11111101," line8="    a = 0b11111110," line9="  ' ' = 0b11111111" line10="}" numlines="11"></mutation><next><block type="typescript_statement" id="LXwl,F_xYzas;;/zy*^a" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum OnOff {" line1="    On = 1," line2="    Off = 0" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="U9lNKH+84GV;~do?;yCh" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum RgbLedPin {" line1="    R_Pin = 0," line2="    G_Pin = 1," line3="    B_Pin = 12" line4="}" numlines="5"></mutation><next><block type="typescript_statement" id="}@kA8flB+#M%i%J3(cye" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Humiture {" line1="    Temperature = 0," line2="    Humidity = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="(*Jgyg.;a[%dTXdNny7a" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Sensor {" line1="    IR_receiver = 0x04," line2="    Microphone = 0x00," line3="    Potentiometer = 0x02" line4="}" numlines="5"></mutation><next><block type="typescript_statement" id="Nu,wG,:o3O8Q]0;CMv,k" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Veer {" line1="    CW = 0," line2="    CCW = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="=o~,j)]W{Ll9=d80JPkn" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Mosiwi_basic_learning_kit {" line1="    // Compute a Dallas Semiconductor 8 bit CRC directly." line2="    // this is much slower, but a little smaller, than the lookup table." line3="    // https://www.analog.com/en/technical-articles/understanding-and-using-cyclic-redundancy-checks-with-maxim-1wire-and-ibutton-products.html" line4="    function crc8(addr: any[], len: number) {" line5="        let i: number = 0;" line6="        let a: number = 0;" line7="        let crc: number = 0;" line8="        while (len--) {" line9="            crc ^= addr[a];" line10="            a++;" line11="            for (i = 0; i &lt; 8; ++i) {" line12="                // Anti-order CRC8" line13="                // 1. X8+X5+X4+1 = 100110001 &#9;&#9;  " line14="                // 2. The calculation of reverse XOR is used : 100110001 ---&gt; 100011001" line15="                // 3. The lowest bit of data is not processed : 100011001 ---&gt; 10001100" line16="                //    (Move (discard) one bit if the lowest bit of both the data and the polynomial is 1)" line17="                // 4. 10001100 = 0x8C" line18="                if (crc &amp; 0x01)" line19="                    crc = (crc &gt;&gt; 1) ^ 0x8C;" line20="                else" line21="                    crc = (crc &gt;&gt; 1);" line22="            }" line23="        }" line24="        return crc;" line25="    }" line26="" line27="    function crc16(input: any[], len: number) {" line28="        let j: number = 0;" line29="        let b: number = 0;" line30="        let crc2: number = 0x0000;" line31="        while (len--) {" line32="            crc2 ^= input[b];" line33="            b++;" line34="            for (j = 0; j &lt; 8; ++j) {" line35="                // Anti-order CRC16" line36="                // 1. X16+X15+X2+1 = 11000000000000101 &#9;&#9;  " line37="                // 2. The calculation of reverse XOR is used : 11000000000000101 ---&gt; 10100000000000011" line38="                // 3. The lowest bit of data is not processed : 10100000000000011 ---&gt; 1010000000000001" line39="                //    (Move (discard) one bit if the lowest bit of both the data and the polynomial is 1)" line40="                // 4. 1010000000000001 = 0xA001" line41="                if (crc2 &amp; 0x01)" line42="                    crc2 = (crc2 &gt;&gt; 1) ^ 0xA001;" line43="                else" line44="                    crc2 = (crc2 &gt;&gt; 1);" line45="            }" line46="        }" line47="        return crc2;" line48="    }" line49="" line50="" line51="    // They correspond to 4-bit digital tube and can control 8 digital sections of the code tube." line52="    // default = 0xff, bit: on = 0, off = 1" line53="    // D7  D6  D5  D4  D3  D2  D1  D0" line54="    // DP  G   F   E   D   C   B   A" line55="    const DisReg0 = 0x00;" line56="    const DisReg1 = 0x01;" line57="    const DisReg2 = 0x02;" line58="    const DisReg3 = 0x03;" line59="" line60="    // The user can input the value and get the digital display directly." line61="    // D7  D6  D5  D4  D3  D2  D1  D0" line62="    // A3  A2  A1  A0  d3  d2  d1  d0" line63="    // A3:A0 controls which digit bits are displayed." line64="    // d3:d0 = 0---F" line65="    const DecReg = 0x1B;" line66="" line67="    // Realize display control in unit of segment" line68="    //    DP   G   F   E   D   C   B   A" line69="    // 0  07   06  05  04  03  02  01  00" line70="    // 1  0F   0F  0D  0C  0B  0A  09  08   " line71="    // 2  17   16  15  14  13  12  11  10" line72="    // 3  1F   1E  1D  1C  1B  1A  19  18" line73="    // data format:" line74="    // D7  D6  D5  D4  D3  D2  D1  D0" line75="    // Seg A6  A5  A4  A3  A2  A1  A0" line76="    // A5:A0 = data address, Seg = 0 = on, Seg = 1 = off  " line77="    const SegAddReg = 0x1C;" line78="" line79="    // Clear the screen or light up all leds." line80="    const GloReg = 0x1D;" line81="" line82="    function BC7278_spi_read_data(addr: number, dat: number): number {" line83="        let data: number = 0;" line84="        data = pins.spiWrite(addr);" line85="        data = ((data &lt;&lt; 8) &amp; 0xff00) + (pins.spiWrite(dat) &amp; 0xff);" line86="        return data;" line87="    }" line88="" line89="    function BC7278_spi_write_data(addr: number, dat: number) {" line90="        pins.spiWrite(addr);" line91="        pins.spiWrite(dat);" line92="    }" line93="" line94="    ////////////////////////////////////////////" line95="    // display segment" line96="    // Seg   DP    G    F    E    D    C    B    A" line97="    // Bit " line98="    //  0    7h    6h   5h   4h   3h   2h   1h   0h" line99="    //  1    fh    eh   dh   ch   bh   ah   9h   8h" line100="    //  2    17h   16h  15h  14h  13h  12h  11h  10h" line101="    //  3    1fh   1eh  1dh  1ch  1bh  1ah  19h  18h" line102="    //  " line103="    // OnOff = 1 = on, OnOff = 0 = off" line104="    function SetDisplaySeg(Seg: number, OnOff: number) {" line105="        if (OnOff != 0 &amp;&amp; OnOff != 1)" line106="            return;" line107="        Seg = ((~OnOff) &lt;&lt; 7) + Seg;" line108="        BC7278_spi_write_data(SegAddReg, Seg);" line109="    }" line110="" line111="    /////////////////////////////////////////////////////" line112="    //% block=&quot;Digital-tube-button-init&quot;" line113="    //% group=&quot;Digital-Tube_Button&quot; weight=7" line114="    export function Digital_Tube_Button_Init() {" line115="        pins.spiPins(DigitalPin.P15, DigitalPin.P14, DigitalPin.P13);" line116="        pins.spiFormat(8, 3);" line117="        pins.spiFrequency(60000);" line118="    }" line119="" line120="    ////////////////////////////////////////////" line121="    //% block=&quot;Keypad-interrupt-output&quot;" line122="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line123="    export function Buton_pin() {" line124="        return EventBusSource.MICROBIT_ID_BUTTON_B;     //P11" line125="    }" line126="" line127="    ////////////////////////////////////////////" line128="    //            bit: 0 0 0  x x x x x" line129="    // Read key value: 0 0 0 OK U D L R" line130="    // x = 1, There's no button to press. " line131="    // x = 0, There are buttons to press." line132="    //% block=&quot;Get-keypad-value&quot;" line133="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line134="    export function Read_button() {" line135="        // 0xff: pseudoinstruction" line136="        // Gets 16 key values" line137="        let allKey: number = BC7278_spi_read_data(0xff, 0xff);" line138="" line139="        // After processing data, obtain the key values of S11-S15." line140="        let keyValue: number = ((~allKey) &gt;&gt; 11) &amp; 0x1f;" line141="" line142="        return keyValue;" line143="    }" line144="" line145="    /////////////////////////////////////////////////////" line146="    //% block=&quot;Digital-tube-clear&quot;" line147="    //% group=&quot;Digital-Tube_Button&quot; weight=5" line148="    export function Digital_Tube_Clear() {" line149="        BC7278_spi_write_data(GloReg, 0xff);" line150="    }" line151="" line152="    ////////////////////////////////////////////" line153="    // display: 0-9999 or 0.0-999.9" line154="    //% block=&quot;Digital-tube-num: $num&quot;" line155="    //% group=&quot;Digital-Tube_Button&quot; weight=4" line156="    export function DisplayNumber(num: number) {" line157="        let dat: number = 0;" line158="        if (parseInt(num.toString()) == parseFloat(num.toString())) {  //integer" line159="            dat = num;" line160="            SetDisplaySeg(0x17, 0);           // Turn off the decimal point." line161="        }" line162="        else {                                                          //flaot" line163="            dat = ~~(num * 10);" line164="            SetDisplaySeg(0x17, 1);           // Turn on the decimal point." line165="        }" line166="" line167="        dat = dat % 10000;" line168="        if (~~(dat / 1000) != 0) {" line169="            Digital_Tube_Num(0, ~~(dat / 1000));" line170="            Digital_Tube_Num(1, ~~(dat % 1000 / 100));" line171="            Digital_Tube_Num(2, ~~(dat % 100 / 10));" line172="            Digital_Tube_Num(3, dat % 10);" line173="            return;" line174="        }" line175="        if (~~(dat / 100) != 0) {" line176="            Digital_Tube_Seg(0, 0xff);" line177="            Digital_Tube_Num(1, ~~(dat / 100));" line178="            Digital_Tube_Num(2, ~~(dat % 100 / 10));" line179="            Digital_Tube_Num(3, dat % 10);" line180="            return;" line181="        }" line182="    " line183="        if (~~(dat / 10) != 0) {" line184="            Digital_Tube_Seg(0, 0xff);" line185="            Digital_Tube_Seg(1, 0xff);" line186="            Digital_Tube_Num(2, ~~(dat / 10));" line187="            Digital_Tube_Num(3, dat % 10);" line188="            return;" line189="        }" line190="" line191="        Digital_Tube_Seg(0, 0xff);" line192="        Digital_Tube_Seg(1, 0xff);" line193="        Digital_Tube_Seg(2, 0xff);" line194="        Digital_Tube_Num(3, dat);" line195="    }" line196="" line197="    ////////////////////////////////////////////" line198="    // display: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,  b,  C,  d,  E,  F" line199="    // Number : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15" line200="    // Position : 0, 1, 2, 3" line201="    //% block=&quot;Digital-Tube_Num: position $Position num $Number&quot;" line202="    //% Position.min=0 Position.max=3 Number.min=0 Number.max=9" line203="    //% group=&quot;Digital-Tube_Button&quot; weight=3" line204="    export function Digital_Tube_Num(Position: number, Number: number) {" line205="        if (Position &gt; 3 || Number &gt; 15)" line206="            return;" line207="        let dat2: number = 0;" line208="        dat2 = (Position &lt;&lt; 4) | Number;" line209="        BC7278_spi_write_data(DecReg, dat2);" line210="    }" line211="" line212="    ////////////////////////////////////////////" line213="    // segment" line214="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line215="    //% block=&quot;Segment: $Seg&quot;" line216="    //% group=&quot;Digital-Tube_Button&quot; weight=2" line217="    export function Segment(Seg: segment): number {" line218="        return Seg;" line219="    }" line220="" line221="    ////////////////////////////////////////////" line222="    // display segment" line223="    // Position: 0--3" line224="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line225="    //% block=&quot;Digital-Tube_Seg: position $Position segment $Seg&quot;" line226="    //% Position.min=0 Position.max=3" line227="    //% group=&quot;Digital-Tube_Button&quot; weight=1" line228="    export function Digital_Tube_Seg(Position: number, Seg: number) {" line229="        let addr: number = 0;" line230="        switch (Position) {" line231="            case 0: addr = DisReg0; break;" line232="            case 1: addr = DisReg1; break;" line233="            case 2: addr = DisReg2; break;" line234="            case 3: addr = DisReg3; break;" line235="            default: return;" line236="        }" line237="        BC7278_spi_write_data(addr, Seg);" line238="    }" line239="" line240="" line241="" line242="    const LSBFIRST: number = 1;" line243="    const MSBFIRST: number = 0;" line244="    let ledData: number = 0;" line245="" line246="    //////////////////////////////////////////////////////////////" line247="    // Send 8-bit data to 74HC595." line248="    function ShiftOut(val: number) {" line249="        let k: number;" line250="        let bit: number = 0x80;" line251="        for (k = 0; k &lt; 8; k++) {" line252="            pins.digitalWritePin(DigitalPin.P16, val &amp; bit);" line253="            bit = (bit &gt;&gt; 1) &amp; 0xff;" line254="" line255="            pins.digitalWritePin(DigitalPin.P8, 1);" line256="            control.waitMicros(10);" line257="            pins.digitalWritePin(DigitalPin.P8, 0);" line258="            control.waitMicros(10);" line259="        }" line260="    }" line261="" line262="    ////////////////////////////////////////////" line263="    //% block=&quot;$Onoff&quot;" line264="    //% group=&quot;Led&quot; weight=2" line265="    export function On_Off(Onoff: OnOff): number {" line266="        return Onoff;" line267="    }" line268="" line269="    ////////////////////////////////////////////" line270="    // LED" line271="    //% block=&quot;Set $Pos led  $OnOff&quot;" line272="    //% Pos.min=0 Pos.max=8 OnOff.min=0 OnOff.max=1" line273="    //% group=&quot;Led&quot; weight=1" line274="    export function Set_Led(Pos: number, OnOff: number) {" line275="        if (Pos &gt; 8 || OnOff &gt; 1) {" line276="            return;" line277="        }" line278="        if (OnOff == 1) {" line279="            ledData = ledData | (1 &lt;&lt; (Pos - 1));" line280="        }" line281="        else {" line282="            ledData = ledData &amp; ((~(1 &lt;&lt; (Pos - 1))) &amp; 0xff);" line283="        }" line284="        //ground latchPin and hold low for as long as you are transmitting" line285="        pins.digitalWritePin(DigitalPin.P9, 0);" line286="        ShiftOut(ledData);" line287="        //no longer needs to listen for information" line288="        pins.digitalWritePin(DigitalPin.P9, 1);" line289="    }" line290="" line291="" line292="" line293="    ////////////////////////////////////////////" line294="    //% block=&quot;RGB-LED $Pin PWM $pwm&quot;" line295="    //% pwm.min=0 pwm.max=1023" line296="    //% group=&quot;RGB_Led&quot; weight=1" line297="    export function RgbLed_pin(Pin: RgbLedPin, pwm: number) {" line298="        if (Pin == 0)" line299="            pins.analogWritePin(AnalogPin.P0, pwm);" line300="        else if (Pin == 1)" line301="            pins.analogWritePin(AnalogPin.P1, pwm);" line302="        else if (Pin == 12)" line303="            pins.analogWritePin(AnalogPin.P12, pwm);" line304="    }" line305="" line306="" line307="" line308="    // AHT20 Register address&#9;&#9;" line309="    const reg1_ = 0x1b;" line310="    const reg2_ = 0x1c;" line311="    const reg3_ = 0x1e;" line312="    const ac_ = 0xac;" line313="    const ac_d1 = 0x33;" line314="    const ac_d2 = 0x00;" line315="    const aht20Addr = 0x38;" line316="    let ct = [0, 0];" line317="" line318="    ////////////////////////////////////////////" line319="    function SendAC() {" line320="        pins.i2cWriteNumber(aht20Addr, ac_, NumberFormat.Int8LE, true);" line321="        pins.i2cWriteNumber(aht20Addr, ac_d1, NumberFormat.Int8LE, true);" line322="        pins.i2cWriteNumber(aht20Addr, ac_d2, NumberFormat.Int8LE, false);" line323="    }" line324="" line325="    ////////////////////////////////////////////" line326="    function Reset_REG(reg: number) {" line327="        let Byte = [0, 0, 0];" line328="" line329="        pins.i2cWriteNumber(aht20Addr, reg, NumberFormat.Int8LE, true);" line330="        pins.i2cWriteNumber(aht20Addr, 0x00, NumberFormat.Int8LE, true);" line331="        pins.i2cWriteNumber(aht20Addr, 0x00, NumberFormat.Int8LE, false);" line332="" line333="        basic.pause(5);" line334="        Byte[0] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line335="        Byte[1] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line336="        Byte[2] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line337="" line338="        basic.pause(10);" line339="        pins.i2cWriteNumber(aht20Addr, 0xb0 | reg, NumberFormat.Int8LE, true);" line340="        pins.i2cWriteNumber(aht20Addr, Byte[1], NumberFormat.Int8LE, true);" line341="        pins.i2cWriteNumber(aht20Addr, Byte[2], NumberFormat.Int8LE, false);" line342="    }" line343="" line344="    ////////////////////////////////////////////" line345="    function Read_Status() {" line346="        let stat;" line347="        stat = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line348="        return stat;" line349="    }" line350="" line351="    ////////////////////////////////////////////" line352="    //% block=&quot;Humiture_init&quot;" line353="    //% group=&quot;Humiture&quot; weight=3" line354="    ////////////////////////////////////////////" line355="    export function AHT20_Init() {" line356="        Reset_REG(reg1_);" line357="        Reset_REG(reg2_);" line358="        Reset_REG(reg3_);" line359="    }" line360="" line361="    ///////////////////////////////////////////" line362="    //No CRC check, read AHT20 temperature and humidity data directly" line363="    //% block=&quot;Read_humiture&quot;" line364="    //% group=&quot;Humiture&quot; weight=2" line365="    export function Read_CTdata() {" line366="        let Byte2 = [0, 0, 0, 0, 0, 0];" line367="        let RetuData = 0;" line368="        let cnt = 0;" line369="" line370="        SendAC();                // Send the AC command to AHT20" line371="        basic.pause(80);" line372="" line373="        //Until bit[7] is 0, indicating idle state. If it is 1, indicating busy state" line374="        while (((Read_Status() &amp; 0x80) == 0x80)) {" line375="            basic.pause(2);" line376="            if (cnt++ &gt;= 100) {" line377="                return false;" line378="            }" line379="        }" line380="        Byte2[0] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line381="        Byte2[1] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line382="        Byte2[2] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line383="        Byte2[3] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line384="        Byte2[4] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, true);" line385="        Byte2[5] = pins.i2cReadNumber(aht20Addr, NumberFormat.Int8LE, false);" line386="" line387="        // Byte[0]  //Status word: the state is 0x98, indicating busy state, and bit[7] is 1.  The state is 0x1C, or 0x0C, or 0x08 is idle, and bit[7] is 0.  " line388="        // Byte[1]  //humidity " line389="        // Byte[2]  //humidity " line390="        // Byte[3]  //humidity / temperature" line391="        // Byte[4]  //temperature " line392="        // Byte[5]  //temperature " line393="        RetuData = (RetuData | Byte2[1]) &lt;&lt; 8;" line394="        RetuData = (RetuData | Byte2[2]) &lt;&lt; 8;" line395="        RetuData = (RetuData | Byte2[3]);" line396="        RetuData = RetuData &gt;&gt; 4;" line397="        ct[0] = RetuData * 100 / 1024 / 1024;           //humidity " line398="        RetuData = 0;" line399="        RetuData = (RetuData | Byte2[3]) &lt;&lt; 8;" line400="        RetuData = (RetuData | Byte2[4]) &lt;&lt; 8;" line401="        RetuData = (RetuData | Byte2[5]);" line402="        RetuData = RetuData &amp; 0xfffff;" line403="        ct[1] = RetuData * 200 / 1024 / 1024 - 50;        //temperature " line404="        return true;" line405="    }" line406="" line407="    ////////////////////////////////////////////" line408="    //% block=&quot;$TH&quot;" line409="    //% group=&quot;Humiture&quot; weight=1" line410="    ////////////////////////////////////////////" line411="    export function Humiture_data(TH: Humiture) {" line412="        if (TH == Humiture.Humidity) {" line413="            return ct[0];" line414="        }" line415="        else {" line416="            return ct[1];" line417="        }" line418="    }" line419="" line420="" line421="" line422="    ////////////////////////////////////////////" line423="    //% block=&quot;Ultrasonic(cm)&quot;" line424="    //% group=&quot;Ultrasonic&quot; weight=1" line425="    ////////////////////////////////////////////" line426="    export function Ultrasonic_() {" line427="        let t: number = 0;" line428="        pins.digitalWritePin(DigitalPin.P0, 1);" line429="        control.waitMicros(10);" line430="        pins.digitalWritePin(DigitalPin.P0, 0);" line431="" line432="        t = pins.pulseIn(DigitalPin.P1, PulseValue.High);" line433="        return t / 29 / 2;" line434="    }" line435="" line436="" line437="" line438="    ////////////////////////////////////////////" line439="    //% block=&quot;I2c-read $sensor&quot;" line440="    //% group=&quot;I2c_read&quot; weight=1" line441="    ////////////////////////////////////////////" line442="    export function I2c_read(sensor: Sensor): number {" line443="        let address: number = 0x2d;" line444="        let buffer_result = pins.createBuffer(2);" line445="        let buffer_reg = pins.createBuffer(1);" line446="        let result: number = 0;" line447="" line448="        buffer_reg[0] = sensor;" line449="        pins.i2cWriteBuffer(address, buffer_reg, true);" line450="        buffer_result = pins.i2cReadBuffer(address, 2, false);" line451="        result = buffer_result[0]*256 + buffer_result[1];" line452="        //pins.i2cWriteNumber(address, sensor, NumberFormat.UInt8LE, true);" line453="        //result = pins.i2cReadNumber(address, NumberFormat.UInt16LE, false);" line454="        return result &amp; 0xffff;" line455="    }" line456="" line457="" line458="" line459="    ////////////////////////////////////////////" line460="    //% block=&quot;Fan $_Veer speed $Speed&quot;" line461="    //% Speed.min=0 Speed.max=1023" line462="    //% group=&quot;Fan&quot; weight=1" line463="    ////////////////////////////////////////////" line464="    export function Fan_(_Veer: Veer, Speed: number) {" line465="        if (_Veer == Veer.CW) {" line466="            pins.digitalWritePin(DigitalPin.P0, 0);" line467="            pins.analogWritePin(AnalogPin.P1, Speed)" line468="        }" line469="        else {" line470="            pins.analogWritePin(AnalogPin.P0, Speed)" line471="            pins.digitalWritePin(DigitalPin.P1, 0);" line472="        }" line473="    }" line474="" line475="" line476="    ////////////////////////////////////////////" line477="    //% block=&quot;Buzzer_Pin&quot;" line478="    //% group=&quot;Buzzer&quot; weight=1" line479="    export function Buzzer_pin() {" line480="        return DigitalPin.P3;" line481="    }" line482="" line483="" line484="    ////////////////////////////////////////////" line485="    //% block=&quot;Button_Pin&quot;" line486="    //% group=&quot;Button&quot; weight=1" line487="    export function Button_pin() {" line488="        return DigitalPin.P5;" line489="    }" line490="" line491="" line492="    // Perform the onewire reset function.  We will wait up to 250uS for" line493="    // the bus to come high, if it doesn't then it is broken or shorted" line494="    // and we return a 0;" line495="    // Returns 1 if a device asserted a presence pulse, 0 otherwise." line496="    function OneWire_reset() {" line497="        let r: number;" line498="        let retries: number = 125;" line499="        // wait until the wire is high... just in case" line500="        do {" line501="            if (--retries == 0) return 0;" line502="            control.waitMicros(2);" line503="        } while (!pins.digitalReadPin(DigitalPin.P7));" line504="" line505="        pins.digitalWritePin(DigitalPin.P7, 0);" line506="        control.waitMicros(550);" line507="        r = pins.digitalReadPin(DigitalPin.P7);" line508="        control.waitMicros(410);" line509="        return r;" line510="    }" line511="" line512="    // Write a bit. Port and bit is used to cut lookup time and provide" line513="    // more certain timing." line514="    function OneWire_write_bit(v: number) {" line515="        if (v &amp; 1) {   // write bit 1&#9;" line516="            pins.digitalWritePin(DigitalPin.P7, 0);" line517="            control.waitMicros(10);" line518="            pins.digitalWritePin(DigitalPin.P7, 1);" line519="            control.waitMicros(55);" line520="        } else {      // write bit 0" line521="            pins.digitalWritePin(DigitalPin.P7, 0);" line522="            control.waitMicros(65);" line523="            pins.digitalWritePin(DigitalPin.P7, 1);" line524="            control.waitMicros(5);" line525="        }" line526="    }" line527="" line528="    // Read a bit. Port and bit is used to cut lookup time and provide" line529="    // more certain timing." line530="    function OneWire_read_bit() {" line531="        let s: number;" line532="        pins.digitalWritePin(DigitalPin.P7, 0);" line533="        control.waitMicros(13);" line534="        s = pins.digitalReadPin(DigitalPin.P7);" line535="        control.waitMicros(53);" line536="        return s;" line537="    }" line538="" line539="    // Write a byte. " line540="    function OneWire_write_byte(v: number) {" line541="        let bitMask: number;" line542="        for (bitMask = 0x01; bitMask; bitMask &lt;&lt;= 1) {" line543="            OneWire_write_bit((bitMask &amp; v) ? 1 : 0);" line544="        }" line545="    }" line546="" line547="    // Read a byte" line548="    function OneWire_read_byte() {" line549="        let bitMask2: number;" line550="        let u: number = 0;" line551="        for (bitMask2 = 0x01; bitMask2; bitMask2 &lt;&lt;= 1) {" line552="            if (OneWire_read_bit()) u |= bitMask2;" line553="        }" line554="        return u;" line555="    }" line556="" line557="" line558="" line559="    let ROM_NUM = [0, 0, 0, 0, 0, 0, 0, 0];" line560="    ////////////////////////////////////////////" line561="    //% block=&quot;Search_device&quot;" line562="    //% group=&quot;Storer&quot; weight=6" line563="    export function EEPROM_search_ROM() {" line564="        let id_bit: number = 0;" line565="        let cmp_id_bit: number = 0;" line566="        let c: number = 0;" line567="        let l: number = 0;" line568="" line569="        for (l = 0; l &lt; 8; l++)" line570="            ROM_NUM[l] = 0;" line571="" line572="        // The device will be reset and found." line573="        // If the device is not found, return false." line574="        if (!OneWire_reset())" line575="            return false;" line576="" line577="        OneWire_write_byte(0xF0);     // Search ROM" line578="" line579="        do {" line580="            // read a bit and its complement" line581="            id_bit = OneWire_read_bit();" line582="            cmp_id_bit = OneWire_read_bit();" line583="            // check for no devices on 1-wire" line584="            if ((id_bit == 1) &amp;&amp; (cmp_id_bit == 1)) {" line585="                return false;" line586="            } else {" line587="                if ((id_bit == 0) &amp;&amp; (cmp_id_bit == 0))" line588="                    // Multiple devices found on 1-wire" line589="                    return false;" line590="            }" line591="            if (id_bit)" line592="                ROM_NUM[c / 8] |= 0x01 &lt;&lt; (c % 8);" line593="" line594="            OneWire_write_bit(id_bit);" line595="            c++;" line596="        } while (c &lt; 64);" line597="" line598="        // A device was found but the serial number CRC is invalid." line599="        if (crc8(ROM_NUM, 7) != ROM_NUM[7])" line600="            return false;" line601="" line602="        // Family code error" line603="        if (ROM_NUM[0] != 0x2D)" line604="            return false;" line605="" line606="        return true;" line607="    }" line608="" line609="    function EEPROM_check_crc16(input: any[], len: number, inverted_crc: any[]) {" line610="        let crc3: number = ~crc16(input, len);" line611="        return (crc3 &amp; 0xFF) == inverted_crc[0] &amp;&amp; (crc3 &gt;&gt; 8) == inverted_crc[1];" line612="    }" line613="" line614="    // slect ROM" line615="    function EEPROM_slect_rom() {" line616="        let m: number = 0;" line617="        OneWire_reset();              // initial signal" line618="        OneWire_write_byte(0x55);     // Match ROM" line619="        for (m = 0; m &lt; 8; m++)" line620="            OneWire_write_byte(ROM_NUM[m]);" line621="    }" line622="" line623="    ////////////////////////////////////////////" line624="    //% block=&quot;Get_device&quot;" line625="    //% group=&quot;Storer&quot; weight=5" line626="    export function Return_ROM() {" line627="        return ROM_NUM;" line628="    }" line629="" line630="    // Read a byte of data from eeprom." line631="    //% block=&quot;Read data from $address&quot;" line632="    //% address.min=0 address.max=16" line633="    //% group=&quot;Storer&quot; weight=4" line634="    export function EEPROM_read(address: number) {" line635="        address = address * 8;" line636="        EEPROM_slect_rom();              // Match ROM" line637="        OneWire_write_byte(0xF0);     // read memory" line638="        OneWire_write_byte(address &amp; 0x00ff);" line639="        OneWire_write_byte((address &amp; 0xff00) &gt;&gt; 8);" line640="        return OneWire_read_byte();" line641="    }" line642="" line643="    /**" line644="     * Write a 8-byte row, must write 8 bytes at a time." line645="     * @param buf --&gt; An array of 8 members." line646="     * @param address" line647="     */" line648="    //% block=&quot;Write array $buf to $address&quot;" line649="    //% address.min=0 address.max=15" line650="    //% group=&quot;Storer&quot; weight=3" line651="    export function EEPROM_write(buf: any[], address: number) {" line652="        let verify: boolean = false;" line653="        let crc16 = [0, 0];    // store value of crc" line654="        let buffer = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];       // data)+command = 12bytes" line655="        let n: number = 0;" line656="" line657="        // 1.write scratchpad --&gt; Write data to the scratchpad" line658="        buffer[0] = 0x0F;                   // store commands --&gt; write scratchpad" line659="        buffer[1] = address &amp; 0x00ff;       // address" line660="        buffer[2] = (address &amp; 0xff00) &gt;&gt; 8;" line661="        for (n = 0; n &lt; 8; n++) {" line662="            buffer[n + 3] = buf[n];         // 8 bytes data" line663="        }" line664="" line665="        EEPROM_slect_rom();                        // Match ROM" line666="        OneWire_write_byte(buffer[0]);          // CMD ---&gt; write scratchpad" line667="        OneWire_write_byte(buffer[1]);          // address" line668="        OneWire_write_byte(buffer[2]);" line669="" line670="        for (n = 3; n &lt; 11; n++)  // write 8 bytes data to eeprom" line671="            OneWire_write_byte(buffer[n]);" line672="" line673="        crc16[0] = OneWire_read_byte();         // Read CRC-16" line674="        crc16[1] = OneWire_read_byte();" line675="        if (!EEPROM_check_crc16(buffer, 11, crc16))" line676="            verify = true; //CRC not matching, try to read again" line677="" line678="        // 2.read scratchpad --&gt; Read data from the scratchpad" line679="        buffer[0] = 0xAA;                   // store commands --&gt; read scratchpad" line680="        EEPROM_slect_rom();                        // Match ROM" line681="        OneWire_write_byte(buffer[0]);          // CMD ---&gt; read scratchpad" line682="" line683="        for (n = 1; n &lt; 4; n++)            //Read TA1(Low address), TA2(High address) and E/S" line684="            buffer[n] = OneWire_read_byte();" line685="" line686="        if (buffer[3] != 0x07)              // E/S must be equal to 0x07(8 bytes data)" line687="            return false;" line688="" line689="        if (verify) {" line690="            for (n = 4; n &lt; 12; n++) //Read the data of scratchpad(8 bytes)" line691="                buffer[n] = OneWire_read_byte();" line692="" line693="            crc16[0] = OneWire_read_byte();        // Read CRC-16" line694="            crc16[1] = OneWire_read_byte();" line695="            if (!EEPROM_check_crc16(buffer, 12, crc16))  // CRC not matching." line696="                return false;" line697="        }" line698="" line699="        // 3.Copy scratchpad --&gt; Write the data in the scratchpad to memory" line700="        buffer[0] = 0x55;          // CMD --&gt; Copy scratchpad" line701="        EEPROM_slect_rom();               // Match ROM" line702="        for (n = 0; n &lt; 4; n++)   //Send authorization code (TA1, TA2, E/S)" line703="            OneWire_write_byte(buffer[n]);" line704="" line705="        basic.pause(15);                 // t_PROG = 12.5ms worst case." line706="        let res: number = OneWire_read_byte();  // Read copy status, 0xAA = success" line707="        if (res != 0xAA) {" line708="            return false;" line709="        }" line710="        return true;" line711="    }" line712="}" numlines="713"></mutation></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>