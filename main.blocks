<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="x03}cT;3xh_}iRHZ@,av" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="~|lo38v2SEO6ljAOaNUi" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum segment {" line1="   dp = 0b01111111," line2="    g = 0b10111111," line3="    f = 0b11011111," line4="    e = 0b11101111," line5="    d = 0b11110111," line6="    c = 0b11111011," line7="    b = 0b11111101," line8="    a = 0b11111110," line9="  ' ' = 0b11111111" line10="}" numlines="11"></mutation><next><block type="typescript_statement" id="P=$U5Cb.]%8]=2V]UVLY" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum OnOff {" line1="    On = 1," line2="    Off = 0" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="eT:|2#Z]C`qsCp]X=e%k" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum RgbLedPin {" line1="    R_Pin = 0," line2="    G_Pin = 1," line3="    B_Pin = 12" line4="}" numlines="5"></mutation><next><block type="typescript_statement" id="~QZkT@_gEO(iY+fK]Rk{" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Humiture {" line1="    Temperature = 0," line2="    Humidity = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="n}Nw1X_LjRR4p{+:]5wP" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Sensor {" line1="    IR_receiver = 0x04," line2="    Microphone = 0x00," line3="    Potentiometer = 0x02" line4="}" numlines="5"></mutation><next><block type="typescript_statement" id="~H:^xcJ/mWFJXJD8biGq" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="const enum Veer {" line1="    CW = 0," line2="    CCW = 1" line3="}" numlines="4"></mutation><next><block type="typescript_statement" id="~QoSGD6Z-{XZ}3H;dCjs" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace Mosiwi_basic_learning_kit {" line1="    // Compute a Dallas Semiconductor 8 bit CRC directly." line2="    // this is much slower, but a little smaller, than the lookup table." line3="    // https://www.analog.com/en/technical-articles/understanding-and-using-cyclic-redundancy-checks-with-maxim-1wire-and-ibutton-products.html" line4="    function crc8(addr: any[], len: number) {" line5="        let i: number = 0;" line6="        let a: number = 0;" line7="        let crc: number = 0;" line8="        while (len--) {" line9="            crc ^= addr[a];" line10="            a++;" line11="            for (i = 0; i &lt; 8; ++i) {" line12="                // Anti-order CRC8" line13="                // 1. X8+X5+X4+1 = 100110001 &#9;&#9;  " line14="                // 2. The calculation of reverse XOR is used : 100110001 ---&gt; 100011001" line15="                // 3. The lowest bit of data is not processed : 100011001 ---&gt; 10001100" line16="                //    (Move (discard) one bit if the lowest bit of both the data and the polynomial is 1)" line17="                // 4. 10001100 = 0x8C" line18="                if (crc &amp; 0x01)" line19="                    crc = (crc &gt;&gt; 1) ^ 0x8C;" line20="                else" line21="                    crc = (crc &gt;&gt; 1);" line22="            }" line23="        }" line24="        return crc;" line25="    }" line26="" line27="    function crc16(input: any[], len: number) {" line28="        let j: number = 0;" line29="        let b: number = 0;" line30="        let crc2: number = 0x0000;" line31="        while (len--) {" line32="            crc2 ^= input[b];" line33="            b++;" line34="            for (j = 0; j &lt; 8; ++j) {" line35="                // Anti-order CRC16" line36="                // 1. X16+X15+X2+1 = 11000000000000101 &#9;&#9;  " line37="                // 2. The calculation of reverse XOR is used : 11000000000000101 ---&gt; 10100000000000011" line38="                // 3. The lowest bit of data is not processed : 10100000000000011 ---&gt; 1010000000000001" line39="                //    (Move (discard) one bit if the lowest bit of both the data and the polynomial is 1)" line40="                // 4. 1010000000000001 = 0xA001" line41="                if (crc2 &amp; 0x01)" line42="                    crc2 = (crc2 &gt;&gt; 1) ^ 0xA001;" line43="                else" line44="                    crc2 = (crc2 &gt;&gt; 1);" line45="            }" line46="        }" line47="        return crc2;" line48="    }" line49="" line50="" line51="    // They correspond to 4-bit digital tube and can control 8 digital sections of the code tube." line52="    // default = 0xff, bit: on = 0, off = 1" line53="    // D7  D6  D5  D4  D3  D2  D1  D0" line54="    // DP  G   F   E   D   C   B   A" line55="    const DisReg0 = 0x00;" line56="    const DisReg1 = 0x01;" line57="    const DisReg2 = 0x02;" line58="    const DisReg3 = 0x03;" line59="" line60="    // The user can input the value and get the digital display directly." line61="    // D7  D6  D5  D4  D3  D2  D1  D0" line62="    // A3  A2  A1  A0  d3  d2  d1  d0" line63="    // A3:A0 controls which digit bits are displayed." line64="    // d3:d0 = 0---F" line65="    const DecReg = 0x1B;" line66="" line67="    // Realize display control in unit of segment" line68="    //    DP   G   F   E   D   C   B   A" line69="    // 0  07   06  05  04  03  02  01  00" line70="    // 1  0F   0F  0D  0C  0B  0A  09  08   " line71="    // 2  17   16  15  14  13  12  11  10" line72="    // 3  1F   1E  1D  1C  1B  1A  19  18" line73="    // data format:" line74="    // D7  D6  D5  D4  D3  D2  D1  D0" line75="    // Seg A6  A5  A4  A3  A2  A1  A0" line76="    // A5:A0 = data address, Seg = 0 = on, Seg = 1 = off  " line77="    const SegAddReg = 0x1C;" line78="" line79="    // Clear the screen or light up all leds." line80="    const GloReg = 0x1D;" line81="" line82="    function BC7278_spi_read_data(addr: number, dat: number): number {" line83="        let data: number = 0;" line84="        data = pins.spiWrite(addr);" line85="        data = ((data &lt;&lt; 8) &amp; 0xff00) + (pins.spiWrite(dat) &amp; 0xff);" line86="        return data;" line87="    }" line88="" line89="    function BC7278_spi_write_data(addr: number, dat: number) {" line90="        pins.spiWrite(addr);" line91="        pins.spiWrite(dat);" line92="    }" line93="" line94="    ////////////////////////////////////////////" line95="    // display segment" line96="    // Seg   DP    G    F    E    D    C    B    A" line97="    // Bit " line98="    //  0    7h    6h   5h   4h   3h   2h   1h   0h" line99="    //  1    fh    eh   dh   ch   bh   ah   9h   8h" line100="    //  2    17h   16h  15h  14h  13h  12h  11h  10h" line101="    //  3    1fh   1eh  1dh  1ch  1bh  1ah  19h  18h" line102="    //  " line103="    // OnOff = 1 = on, OnOff = 0 = off" line104="    function SetDisplaySeg(Seg: number, OnOff: number) {" line105="        if (OnOff != 0 &amp;&amp; OnOff != 1)" line106="            return;" line107="        Seg = ((~OnOff) &lt;&lt; 7) + Seg;" line108="        BC7278_spi_write_data(SegAddReg, Seg);" line109="    }" line110="" line111="    /////////////////////////////////////////////////////" line112="    //% block=&quot;Digital-tube-button-init&quot;" line113="    //% group=&quot;Digital-Tube_Button&quot; weight=7" line114="    export function Digital_Tube_Button_Init() {" line115="        pins.spiPins(DigitalPin.P15, DigitalPin.P14, DigitalPin.P13);" line116="        pins.spiFormat(8, 3);" line117="        pins.spiFrequency(60000);" line118="    }" line119="" line120="    ////////////////////////////////////////////" line121="    //% block=&quot;Keypad-interrupt-output&quot;" line122="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line123="    export function Buton_pin() {" line124="        return EventBusSource.MICROBIT_ID_BUTTON_B;     //P11" line125="    }" line126="" line127="    ////////////////////////////////////////////" line128="    //            bit: 0 0 0  x x x x x" line129="    // Read key value: 0 0 0 OK U D L R" line130="    // x = 1, There's no button to press. " line131="    // x = 0, There are buttons to press." line132="    //% block=&quot;Get-keypad-value&quot;" line133="    //% group=&quot;Digital-Tube_Button&quot; weight=6" line134="    export function Read_button() {" line135="        // 0xff: pseudoinstruction" line136="        // Gets 16 key values" line137="        let allKey: number = BC7278_spi_read_data(0xff, 0xff);" line138="" line139="        // After processing data, obtain the key values of S11-S15." line140="        let keyValue: number = ((~allKey) &gt;&gt; 11) &amp; 0x1f;" line141="" line142="        return keyValue;" line143="    }" line144="" line145="    /////////////////////////////////////////////////////" line146="    //% block=&quot;Digital-tube-clear&quot;" line147="    //% group=&quot;Digital-Tube_Button&quot; weight=5" line148="    export function Digital_Tube_Clear() {" line149="        BC7278_spi_write_data(GloReg, 0xff);" line150="    }" line151="" line152="    ////////////////////////////////////////////" line153="    // display: 0-9999 or 0.0-999.9" line154="    //% block=&quot;Digital-tube-num: $num&quot;" line155="    //% group=&quot;Digital-Tube_Button&quot; weight=4" line156="    export function DisplayNumber(num: number) {" line157="        let dat: number = 0;" line158="        if (parseInt(num.toString()) == parseFloat(num.toString())) {  //integer" line159="            dat = num;" line160="            SetDisplaySeg(0x17, 0);           // Turn off the decimal point." line161="        }" line162="        else {                                                          //flaot" line163="            dat = ~~(num * 10);" line164="            SetDisplaySeg(0x17, 1);           // Turn on the decimal point." line165="        }" line166="" line167="        dat = dat % 10000;" line168="        if (~~(dat / 1000) != 0) {" line169="            Digital_Tube_Num(0, ~~(dat / 1000));" line170="            Digital_Tube_Num(1, ~~(dat % 1000 / 100));" line171="            Digital_Tube_Num(2, ~~(dat % 100 / 10));" line172="            Digital_Tube_Num(3, dat % 10);" line173="            return;" line174="        }" line175="        if (~~(dat / 100) != 0) {" line176="            Digital_Tube_Seg(0, 0xff);" line177="            Digital_Tube_Num(1, ~~(dat / 100));" line178="            Digital_Tube_Num(2, ~~(dat % 100 / 10));" line179="            Digital_Tube_Num(3, dat % 10);" line180="            return;" line181="        }" line182="    " line183="        if (~~(dat / 10) != 0) {" line184="            Digital_Tube_Seg(0, 0xff);" line185="            Digital_Tube_Seg(1, 0xff);" line186="            Digital_Tube_Num(2, ~~(dat / 10));" line187="            Digital_Tube_Num(3, dat % 10);" line188="            return;" line189="        }" line190="" line191="        Digital_Tube_Seg(0, 0xff);" line192="        Digital_Tube_Seg(1, 0xff);" line193="        Digital_Tube_Seg(2, 0xff);" line194="        Digital_Tube_Num(3, dat);" line195="    }" line196="" line197="    ////////////////////////////////////////////" line198="    // display: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A,  b,  C,  d,  E,  F" line199="    // Number : 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15" line200="    // Position : 0, 1, 2, 3" line201="    //% block=&quot;Digital-Tube_Num: position $Position num $Number&quot;" line202="    //% Position.min=0 Position.max=3 Number.min=0 Number.max=9" line203="    //% group=&quot;Digital-Tube_Button&quot; weight=3" line204="    export function Digital_Tube_Num(Position: number, Number: number) {" line205="        if (Position &gt; 3 || Number &gt; 15)" line206="            return;" line207="        let dat2: number = 0;" line208="        dat2 = (Position &lt;&lt; 4) | Number;" line209="        BC7278_spi_write_data(DecReg, dat2);" line210="    }" line211="" line212="    ////////////////////////////////////////////" line213="    // segment" line214="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line215="    //% block=&quot;Segment: $Seg&quot;" line216="    //% group=&quot;Digital-Tube_Button&quot; weight=2" line217="    export function Segment(Seg: segment): number {" line218="        return Seg;" line219="    }" line220="" line221="    ////////////////////////////////////////////" line222="    // display segment" line223="    // Position: 0--3" line224="    // Seg = xxxxxxxx = DP, G, F, E, D, C, B, A (x=0=on, x=1=off)" line225="    //% block=&quot;Digital-Tube_Seg: position $Position segment $Seg&quot;" line226="    //% Position.min=0 Position.max=3" line227="    //% group=&quot;Digital-Tube_Button&quot; weight=1" line228="    export function Digital_Tube_Seg(Position: number, Seg: number) {" line229="        let addr: number = 0;" line230="        switch (Position) {" line231="            case 0: addr = DisReg0; break;" line232="            case 1: addr = DisReg1; break;" line233="            case 2: addr = DisReg2; break;" line234="            case 3: addr = DisReg3; break;" line235="            default: return;" line236="        }" line237="        BC7278_spi_write_data(addr, Seg);" line238="    }" line239="" line240="" line241="" line242="    const LSBFIRST: number = 1;" line243="    const MSBFIRST: number = 0;" line244="    let ledData: number = 0;" line245="" line246="    //////////////////////////////////////////////////////////////" line247="    // Send 8-bit data to 74HC595." line248="    function ShiftOut(val: number) {" line249="        let k: number;" line250="        let bit: number = 0x80;" line251="        for (k = 0; k &lt; 8; k++) {" line252="            pins.digitalWritePin(DigitalPin.P16, val &amp; bit);" line253="            bit = (bit &gt;&gt; 1) &amp; 0xff;" line254="" line255="            pins.digitalWritePin(DigitalPin.P8, 1);" line256="            control.waitMicros(10);" line257="            pins.digitalWritePin(DigitalPin.P8, 0);" line258="            control.waitMicros(10);" line259="        }" line260="    }" line261="" line262="    ////////////////////////////////////////////" line263="    //% block=&quot;$Onoff&quot;" line264="    //% group=&quot;Led&quot; weight=2" line265="    export function On_Off(Onoff: OnOff): number {" line266="        return Onoff;" line267="    }" line268="" line269="    ////////////////////////////////////////////" line270="    // LED" line271="    //% block=&quot;Set $Pos led  $OnOff&quot;" line272="    //% Pos.min=0 Pos.max=8 OnOff.min=0 OnOff.max=1" line273="    //% group=&quot;Led&quot; weight=1" line274="    export function Set_Led(Pos: number, OnOff: number) {" line275="        if (Pos &gt; 8 || OnOff &gt; 1) {" line276="            return;" line277="        }" line278="        if (OnOff == 1) {" line279="            ledData = ledData | (1 &lt;&lt; (Pos - 1));" line280="        }" line281="        else {" line282="            ledData = ledData &amp; ((~(1 &lt;&lt; (Pos - 1))) &amp; 0xff);" line283="        }" line284="        //ground latchPin and hold low for as long as you are transmitting" line285="        pins.digitalWritePin(DigitalPin.P9, 0);" line286="        ShiftOut(ledData);" line287="        //no longer needs to listen for information" line288="        pins.digitalWritePin(DigitalPin.P9, 1);" line289="    }" line290="" line291="" line292="" line293="    ////////////////////////////////////////////" line294="    //% block=&quot;RGB-LED $Pin PWM $pwm&quot;" line295="    //% pwm.min=0 pwm.max=1023" line296="    //% group=&quot;RGB_Led&quot; weight=1" line297="    export function RgbLed_pin(Pin: RgbLedPin, pwm: number) {" line298="        if (Pin == 0)" line299="            pins.analogWritePin(AnalogPin.P0, pwm);" line300="        else if (Pin == 1)" line301="            pins.analogWritePin(AnalogPin.P1, pwm);" line302="        else if (Pin == 12)" line303="            pins.analogWritePin(AnalogPin.P12, pwm);" line304="    }" line305="" line306="" line307="" line308="    // AHT20 Register address&#9;&#9;" line309="    const reg1_ = 0x1b;" line310="    const reg2_ = 0x1c;" line311="    const reg3_ = 0x1e;" line312="    const ac_ = 0xac;" line313="    const ac_d1 = 0x33;" line314="    const ac_d2 = 0x00;" line315="    const aht20Addr = 0x38;" line316="    let ct = [0, 0];" line317="" line318="    ////////////////////////////////////////////" line319="    function SendAC() {" line320="        let buffer_reg = pins.createBuffer(3);" line321="        buffer_reg[0] = ac_;" line322="        buffer_reg[1] = ac_d1;" line323="        buffer_reg[2] = ac_d2;" line324="        pins.i2cWriteBuffer(aht20Addr, buffer_reg, false);" line325="    }" line326="" line327="    ////////////////////////////////////////////" line328="    function Reset_REG(reg: number) {" line329="        let buffer_reg2 = pins.createBuffer(3);" line330="        let buffer_read = pins.createBuffer(3);" line331="" line332="        buffer_reg2[0] = reg;" line333="        buffer_reg2[1] = 0x00;" line334="        buffer_reg2[2] = 0x00;" line335="        pins.i2cWriteBuffer(aht20Addr, buffer_reg2, false);" line336="        basic.pause(5);" line337="        buffer_read = pins.i2cReadBuffer(aht20Addr, 3, false);" line338="        basic.pause(10);" line339="        buffer_read[0] = buffer_read[0] | reg;" line340="        pins.i2cWriteBuffer(aht20Addr, buffer_read, false);" line341="    }" line342="" line343="    ////////////////////////////////////////////" line344="    function Read_Status():number {" line345="        let buffer_stat = pins.createBuffer(1);" line346="        buffer_stat = pins.i2cReadBuffer(aht20Addr, 1, false);" line347="        return buffer_stat[0];" line348="    }" line349="" line350="    ////////////////////////////////////////////" line351="    //% block=&quot;Humiture_init&quot;" line352="    //% group=&quot;Humiture&quot; weight=3" line353="    ////////////////////////////////////////////" line354="    export function AHT20_Init() {" line355="        Reset_REG(reg1_);" line356="        Reset_REG(reg2_);" line357="        Reset_REG(reg3_);" line358="    }" line359="" line360="    ///////////////////////////////////////////" line361="    //No CRC check, read AHT20 temperature and humidity data directly" line362="    //% block=&quot;Read_humiture&quot;" line363="    //% group=&quot;Humiture&quot; weight=2" line364="    export function Read_CTdata() {" line365="        let buffer_read2 = pins.createBuffer(6);" line366="        let RetuData = 0;" line367="        let cnt = 0;" line368="" line369="        SendAC();                // Send the AC command to AHT20" line370="        basic.pause(80);" line371="" line372="        //Until bit[7] is 0, indicating idle state. If it is 1, indicating busy state" line373="        while (((Read_Status() &amp; 0x80) == 0x80)) {" line374="            basic.pause(2);" line375="            if (cnt++ &gt;= 100) {" line376="                return false;" line377="            }" line378="        }" line379="        buffer_read2 = pins.i2cReadBuffer(aht20Addr, 6, false);" line380="" line381="        // buffer_read[0]  //Status word: the state is 0x98, indicating busy state, and bit[7] is 1.  The state is 0x1C, or 0x0C, or 0x08 is idle, and bit[7] is 0." line382="        // buffer_read[1]  //humidity" line383="        // buffer_read[2]  //humidity" line384="        // buffer_read[3]  //humidity / temperature" line385="        // buffer_read[4]  //temperature" line386="        // buffer_read[5]  //temperature" line387="        RetuData = (RetuData | buffer_read2[1]) &lt;&lt; 8;" line388="        RetuData = (RetuData | buffer_read2[2]) &lt;&lt; 8;" line389="        RetuData = (RetuData | buffer_read2[3]);" line390="        RetuData = RetuData &gt;&gt; 4;" line391="        ct[0] = RetuData * 100 / 1024 / 1024;           //humidity " line392="        RetuData = 0;" line393="        RetuData = (RetuData | buffer_read2[3]) &lt;&lt; 8;" line394="        RetuData = (RetuData | buffer_read2[4]) &lt;&lt; 8;" line395="        RetuData = (RetuData | buffer_read2[5]);" line396="        RetuData = RetuData &amp; 0xfffff;" line397="        ct[1] = RetuData * 200 / 1024 / 1024 - 50;        //temperature " line398="        return true;" line399="    }" line400="" line401="    ////////////////////////////////////////////" line402="    //% block=&quot;$TH&quot;" line403="    //% group=&quot;Humiture&quot; weight=1" line404="    ////////////////////////////////////////////" line405="    export function Humiture_data(TH: Humiture): number {" line406="        if (TH == Humiture.Humidity) {" line407="            return ct[0];" line408="        }" line409="        else {" line410="            return ct[1];" line411="        }" line412="    }" line413="" line414="" line415="" line416="    ////////////////////////////////////////////" line417="    //% block=&quot;Ultrasonic(cm)&quot;" line418="    //% group=&quot;Ultrasonic&quot; weight=1" line419="    ////////////////////////////////////////////" line420="    export function Ultrasonic_() {" line421="        let t: number = 0;" line422="        pins.digitalWritePin(DigitalPin.P0, 1);" line423="        control.waitMicros(10);" line424="        pins.digitalWritePin(DigitalPin.P0, 0);" line425="" line426="        t = pins.pulseIn(DigitalPin.P1, PulseValue.High);" line427="        return t / 29 / 2;" line428="    }" line429="" line430="" line431="" line432="    ////////////////////////////////////////////" line433="    //% block=&quot;I2c-read $sensor&quot;" line434="    //% group=&quot;I2c_read&quot; weight=1" line435="    ////////////////////////////////////////////" line436="    export function I2c_read(sensor: Sensor): number {" line437="        let address: number = 0x2d;" line438="        let buffer_result = pins.createBuffer(2);" line439="        let buffer_reg3 = pins.createBuffer(1);" line440="        let result: number = 0;" line441="" line442="        buffer_reg3[0] = sensor;" line443="        pins.i2cWriteBuffer(address, buffer_reg3, true);" line444="        buffer_result = pins.i2cReadBuffer(address, 2, false);" line445="        result = buffer_result[0]*256 + buffer_result[1];" line446="        //pins.i2cWriteNumber(address, sensor, NumberFormat.UInt8LE, true);" line447="        //result = pins.i2cReadNumber(address, NumberFormat.UInt16LE, false);" line448="        return result &amp; 0xffff;" line449="    }" line450="" line451="" line452="" line453="    ////////////////////////////////////////////" line454="    //% block=&quot;Fan $_Veer speed $Speed&quot;" line455="    //% Speed.min=0 Speed.max=1023" line456="    //% group=&quot;Fan&quot; weight=1" line457="    ////////////////////////////////////////////" line458="    export function Fan_(_Veer: Veer, Speed: number) {" line459="        if (_Veer == Veer.CW) {" line460="            pins.digitalWritePin(DigitalPin.P0, 0);" line461="            pins.analogWritePin(AnalogPin.P1, Speed)" line462="        }" line463="        else {" line464="            pins.analogWritePin(AnalogPin.P0, Speed)" line465="            pins.digitalWritePin(DigitalPin.P1, 0);" line466="        }" line467="    }" line468="" line469="" line470="    ////////////////////////////////////////////" line471="    //% block=&quot;Buzzer_Pin&quot;" line472="    //% group=&quot;Buzzer&quot; weight=1" line473="    export function Buzzer_pin() {" line474="        return DigitalPin.P3;" line475="    }" line476="" line477="" line478="    ////////////////////////////////////////////" line479="    //% block=&quot;Button_Pin&quot;" line480="    //% group=&quot;Button&quot; weight=1" line481="    export function Button_pin() {" line482="        return DigitalPin.P5;" line483="    }" line484="" line485="&#9;/**" line486="     * Read a byte of data from eeprom." line487="&#9; */" line488="&#9;//% shim=ds2431::Read_byte_from_ds2431" line489="    //% block=&quot;Read data from $address&quot;" line490="    //% address.min=0 address.max=16" line491="    //% group=&quot;Storer&quot; weight=4" line492="    export function EEPROM_read(address: number): number{" line493="        return 0;" line494="    }" line495="" line496="    /**" line497="     * Write a 8-byte row, must write 8 bytes at a time." line498="     * @param buf --&gt; An array of 8 members." line499="     * @param address" line500="     */" line501="" line502="    //% block=&quot;Write $dat1 to memory $address address&quot;" line503="    //% address.min=0 address.max=15" line504="    //% group=&quot;Storer&quot; weight=3" line505="&#9;//% inlineInputMode=inline" line506="    export function EEPROM_write(dat1: number, address: number) {" line507="        return false;" line508="    }" line509="}" numlines="510"></mutation></block></next></block></next></block></next></block></next></block></next></block></next></block></statement></block></xml>